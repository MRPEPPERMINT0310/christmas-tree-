<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Merry Christmas</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script>tailwind.config = { theme: { extend: {} } }</script>

  <!-- æ ¸å¿ƒåº“ (unpkgæº) -->
  <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <!-- React / Three.js -->
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
        "react-dom": "https://esm.sh/react-dom@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "three": "https://esm.sh/three@0.160.0",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.12?external=react,react-dom,three",
        "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1?external=react,react-dom,three,@react-three/fiber",
        "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
        "uuid": "https://esm.sh/uuid@9.0.1"
      }
    }
  </script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    body, html, #root { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%); }
    input[type="file"] { display: none; }
    .font-title { font-family: "Brush Script MT", "Comic Sans MS", cursive, serif; }
    .font-cn { font-family: system-ui, -apple-system, "Microsoft YaHei", sans-serif; }
    .glass-btn { background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(8px); border: 1px solid rgba(255, 215, 0, 0.3); color: #FFD700; transition: all 0.3s ease; }
    .glass-btn:hover { background: rgba(255, 217, 0, 0.142); box-shadow: 0 0 25px rgba(255, 215, 0, 0.4); transform: scale(1.05); }
    .magic-hud { position: absolute; top: 80px; right: 24px; width: 160px; height: 120px; border-radius: 12px; overflow: hidden; border: 2px solid rgba(255, 215, 0, 0.6); background: rgba(0,0,0,0.6); z-index: 40; transform: scaleX(-1); }
    .input_video { display: none; }
    #loading-screen { position: fixed; inset: 0; background: #000; z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #FFD700; transition: opacity 0.5s; }
    .loader { width: 48px; height: 48px; border: 5px solid #FFD700; border-bottom-color: transparent; border-radius: 50%; display: inline-block; box-sizing: border-box; animation: rotation 1s linear infinite; margin-bottom: 20px; }
    @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    #error-msg { display: none; color: #ff4444; margin-top: 20px; font-family: sans-serif; text-align: center; padding: 0 20px; }
  
    /* --- Background music toggle button --- */
    .music-btn{
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 9999;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.35);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      user-select: none;
    }
    .music-btn:hover{ transform: translateY(-1px); }
    .music-btn:active{ transform: translateY(0px); }

</style>
</head>
<body>

  <div id="loading-screen">
    <div class="loader"></div>
    <p style="font-family: sans-serif;">SUPRISE HOHOHO...</p>
    <div id="error-msg"></div>
  </div>

  <div id="root"></div>


  <!-- ğŸµ Background music (place bgm.mp3 in the SAME folder as this HTML file) -->
  <audio id="bgm" loop preload="auto">
    <source src="bgm.mp3" type="audio/mpeg" />
    <source src="bgm.ogg" type="audio/ogg" />
  </audio>

  <button id="music-toggle" class="music-btn" aria-pressed="false">ğŸµ Music OFF</button>

  <script>
    (function () {
      const audio = document.getElementById('bgm');
      const btn = document.getElementById('music-toggle');
      if (!audio || !btn) return;

      // Optional: set a comfortable volume
      audio.volume = 0.35;

      let playing = false;

      const setUI = () => {
        btn.textContent = playing ? 'ğŸ”Š Music ON' : 'ğŸµ Music OFF';
        btn.setAttribute('aria-pressed', playing ? 'true' : 'false');
      };
      setUI();

      btn.addEventListener('click', async () => {
        try {
          if (!playing) {
            await audio.play(); // browsers allow after a user click
            playing = true;
          } else {
            audio.pause();
            playing = false;
          }
          setUI();
        } catch (e) {
          console.log('Music play blocked/failed:', e);
          alert('æ— æ³•è‡ªåŠ¨æ’­æ”¾éŸ³ä¹ï¼šè¯·ç¡®è®¤ bgm.mp3 åœ¨åŒä¸€æ–‡ä»¶å¤¹é‡Œï¼Œå¹¶åœ¨é¡µé¢ä¸Šç‚¹å‡»ä¸€æ¬¡åå†è¯•ã€‚');
        }
      });

      // If user pauses from OS controls, update UI
      audio.addEventListener('pause', () => { playing = false; setUI(); });
      audio.addEventListener('play', () => { playing = true; setUI(); });
    })();
  </script>


  <script>
    window.onerror = function(msg, url, line) {
      const errorBox = document.getElementById('error-msg');
      const loader = document.querySelector('.loader');
      if (errorBox) {
        loader.style.display = 'none';
        errorBox.style.display = 'block';
        errorBox.innerHTML = `åŠ è½½ä¼¼ä¹é‡åˆ°äº†é—®é¢˜<br/><small>${msg}</small><br/>è¯·å°è¯•åˆ·æ–°é¡µé¢`;
      }
    };
  </script>

  <script type="text/babel" data-type="module">
    import React, { useState, useRef, useMemo, Suspense, useEffect } from 'react';
    import { createRoot } from 'react-dom/client';
    import * as THREE from 'three';
    import { Canvas, useFrame, useThree } from '@react-three/fiber';
    import { OrbitControls, ContactShadows, Stars } from '@react-three/drei';
    import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

    // ç§»é™¤åŠ è½½å±‚
    setTimeout(() => {
        const loading = document.getElementById('loading-screen');
        if(loading) { loading.style.opacity = '0'; setTimeout(() => loading.style.display = 'none', 500); }
    }, 1000);

    const THEME = { bodyColor: '#004d25', lightColor: '#FFD700', heavyColor: '#8a0a0a', starBodyColor: '#FFD700', gemAColor: '#00FF41', gemBColor: '#FF3333', snowColor: '#ffffff' };

    const snowVertexShader = `
      uniform float uTime; attribute float aScale; attribute vec3 aRandomness; varying float vAlpha;
      void main() {
        vec3 pos = position;
        float fallSpeed = 3.0 + aRandomness.y * 2.0;
        pos.y -= uTime * fallSpeed; pos.y = mod(pos.y + 35.0, 70.0) - 35.0;
        float windStrength = 2.0; float windVariance = sin(uTime * 0.5 + pos.y * 0.1);
        pos.x += (uTime * windStrength) + (windVariance * 2.0); pos.x = mod(pos.x + 40.0, 80.0) - 40.0;
        pos.z += sin(uTime * 0.8 + pos.y * 0.2) * 1.5; pos += aRandomness * 2.0;
        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0); gl_Position = projectionMatrix * mvPosition;
        float size = aScale * (250.0 / -mvPosition.z); gl_PointSize = clamp(size, 2.0, 12.0);
        vAlpha = 0.6 + 0.4 * sin(uTime * 2.0 + aRandomness.x * 100.0);
      }
    `;
    const snowFragmentShader = `
      varying float vAlpha; void main() {
        vec2 c = gl_PointCoord - vec2(0.5); float dist = length(c);
        float alpha = 1.0 - smoothstep(0.0, 0.5, dist); if(alpha < 0.01) discard;
        gl_FragColor = vec4(1.0, 1.0, 1.0, vAlpha * alpha); 
      }
    `;

    const getPineTreePoint = (t, angle, radiusOffset) => {
      const height = 16; const y = t * height; 
      let baseR = (t < 0.1) ? 6.5 + (t / 0.1) * 2.5 : 9.0 * (1 - t);
      const layerWave = Math.sin(t * 25.0) * 0.8 * (1 - t); 
      let r = baseR + layerWave + radiusOffset; if (r < 0) r = 0;
      const x = r * Math.cos(angle); const z = r * Math.sin(angle);
      return new THREE.Vector3(x, y - height / 2 + 1.5, z);
    };

    function createDefaultTexture() {
      const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512; const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#fff'; ctx.fillRect(0,0,512,512); ctx.fillStyle = '#f5f5f5'; ctx.fillRect(40,40,432,380);
      ctx.font = '40px Serif'; ctx.fillStyle = '#ccc'; ctx.textAlign = 'center'; ctx.fillText("PHOTO", 256, 250);
      return new THREE.CanvasTexture(canvas);
    }

    const createStarShape = (size = 0.5) => {
      const s = new THREE.Shape(); const points = 5;
      for (let i = 0; i < points * 2; i++) {
        const l = i % 2 === 1 ? size * 0.4 : size; const a = (i / points) * Math.PI;
        const x = Math.sin(a) * l; const y = Math.cos(a) * l; if (i === 0) s.moveTo(x, y); else s.lineTo(x, y);
      }
      s.closePath(); return s;
    };

    const GestureController = ({ onUpdate }) => {
      const videoRef = useRef(null); const canvasRef = useRef(null); const [status, setStatus] = useState("åˆå§‹åŒ–ä¸­...");
      useEffect(() => {
        if (typeof window.Hands === 'undefined') { setStatus("ç»„ä»¶åŠ è½½å¤±è´¥"); return; }
        const hands = new window.Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults((results) => {
          if (!canvasRef.current) return;
          const ctx = canvasRef.current.getContext('2d');
          ctx.save(); ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
          ctx.drawImage(results.image, 0, 0, canvasRef.current.width, canvasRef.current.height);
          let gestureData = { type: 'NONE', x: 0.5, y: 0.5 };
          if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            window.drawConnectors(ctx, lm, window.HAND_CONNECTIONS, {color: '#FFD700', lineWidth: 2});
            window.drawLandmarks(ctx, lm, {color: '#FFFFFF', lineWidth: 1, radius: 2});
            const isIndexUp = lm[8].y < lm[6].y; const isMiddleUp = lm[12].y < lm[10].y;
            const isRingUp = lm[16].y < lm[14].y; const isPinkyUp = lm[20].y < lm[18].y;
            if (!isIndexUp && !isMiddleUp && !isRingUp && !isPinkyUp) gestureData.type = 'FIST';
            else if (isIndexUp && isMiddleUp && isRingUp && isPinkyUp) gestureData.type = 'OPEN';
            else if (isIndexUp && isMiddleUp && !isRingUp && !isPinkyUp) gestureData.type = 'VICTORY';
            else if (isIndexUp && !isMiddleUp && !isRingUp && !isPinkyUp) gestureData.type = 'POINT';
            gestureData.x = lm[8].x; gestureData.y = lm[8].y;
          }
          onUpdate(gestureData); ctx.restore();
        });
        const camera = new window.Camera(videoRef.current, { onFrame: async () => { if (videoRef.current) await hands.send({image: videoRef.current}); }, width: 320, height: 240 });
        camera.start().then(() => setStatus("Ready")).catch(err => setStatus("æ‘„åƒå¤´æœªæˆæƒ"));
      }, []);
      return (
        <div className="magic-hud">
          <video ref={videoRef} className="input_video"></video>
          <canvas ref={canvasRef} className="output_canvas" width={320} height={240}></canvas>
          {status !== "Ready" && <div className="absolute inset-0 flex items-center justify-center text-white text-xs font-bold bg-black/50">{status}</div>}
        </div>
      );
    };

    const StarTopper = ({ isFormed, color, isLightsOff }) => {
      const ref = useRef();
      const chaosPos = useMemo(() => new THREE.Vector3(0, 50, 0), []); 
      const geometry = useMemo(() => { const shape = createStarShape(1.3); return new THREE.ExtrudeGeometry(shape, { depth: 0.4, bevelEnabled: true, bevelSize: 0.05, bevelThickness: 0.05 }); }, []);
      useFrame((state, delta) => {
        if(!ref.current) return;
        const targetPos = isFormed ? new THREE.Vector3(0, 11.2, 0) : chaosPos; 
        ref.current.position.lerp(targetPos, delta * 1.5);
        const targetScaleVal = isFormed ? 1.0 : 0.8;
        ref.current.scale.lerp(new THREE.Vector3(targetScaleVal, targetScaleVal, targetScaleVal), delta * 2);
        ref.current.rotation.y += delta * 0.5; 
        const targetEmissive = isLightsOff ? 0.2 : 2.0; 
        ref.current.children[0].material.emissiveIntensity = THREE.MathUtils.lerp(ref.current.children[0].material.emissiveIntensity, targetEmissive, delta * 2);
      });
      return (
        <group ref={ref}>
          <mesh geometry={geometry}> <meshStandardMaterial color={color} emissive={color} emissiveIntensity={2.0} toneMapped={false} /> </mesh>
          <pointLight distance={15} intensity={isLightsOff ? 5 : 50} color={color} />
        </group>
      );
    };

    const TreeTrunk = ({ isFormed }) => {
      const ref = useRef();
      useFrame((state, delta) => { if (!ref.current) return; const targetScale = isFormed ? 1 : 0.01; ref.current.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), delta * 1.5); });
      return ( <group ref={ref} position={[0, -8.5, 0]}> <mesh receiveShadow castShadow> <cylinderGeometry args={[1.0, 1.5, 7, 12]} /> <meshStandardMaterial color="#2A1B0E" roughness={0.9} metalness={0.1} /> </mesh> </group> );
    };

    const GiftBoxes = ({ isFormed }) => {
      const groupRef = useRef();
      const gifts = useMemo(() => {
        const colors = ['#8a0a0a', '#003318', '#d4af37', '#c0c0c0'];
        return Array.from({ length: 14 }).map(() => {
          const scale = 0.6 + Math.random() * 0.6; const angle = Math.random() * Math.PI * 2;
          const radius = 2.0 + Math.random() * 3.5; const x = Math.cos(angle) * radius; const z = Math.sin(angle) * radius; const y = -11.5 + scale/2; 
          return { pos: [x, y, z], scale: [scale, scale, scale], color: colors[Math.floor(Math.random() * colors.length)], rotation: [Math.random() * 0.2, Math.random() * Math.PI, Math.random() * 0.2] };
        });
      }, []);
      useFrame((state, delta) => { if (!groupRef.current) return; const targetScale = isFormed ? 1 : 0.01; groupRef.current.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), delta * 2); });
      return (
        <group ref={groupRef}>
          {gifts.map((gift, i) => (
            <group key={i} position={gift.pos} rotation={gift.rotation} scale={gift.scale}>
              <mesh castShadow receiveShadow> <boxGeometry args={[1, 0.9, 1]} /> <meshStandardMaterial color={gift.color} roughness={0.4} metalness={0.2} /> </mesh>
              <mesh position={[0, 0.46, 0]} castShadow> <boxGeometry args={[1.02, 0.05, 0.2]} /> <meshStandardMaterial color="#FFD700" roughness={0.3} metalness={0.8} /> </mesh>
              <mesh position={[0, 0.46, 0]} castShadow> <boxGeometry args={[0.2, 0.05, 1.02]} /> <meshStandardMaterial color="#FFD700" roughness={0.3} metalness={0.8} /> </mesh>
            </group>
          ))}
        </group>
      );
    };

    const CloudySnowFloor = ({ isFormed, isLightsOff }) => {
      const count = 1500; const color = THEME.snowColor; const spread = 12;
      const meshRef = useRef(); const dummy = useMemo(() => new THREE.Object3D(), []);
      const particles = useMemo(() => {
        return Array.from({ length: count }).map(() => {
          const r = Math.pow(Math.random(), 0.6) * spread; const theta = Math.random() * Math.PI * 2; const x = r * Math.cos(theta); const z = r * Math.sin(theta); const heightOffset = Math.max(0, (spread * 0.15) - r * 0.2); const y = -12.0 + Math.random() * 0.5 + heightOffset * 0.2; const randomScale = 0.3 + Math.random() * 0.5;
          return { pos: [x,y,z], randomScale };
        });
      }, [count, spread]);
      useFrame((state, delta) => {
        if (!meshRef.current) return; if (meshRef.current.count !== count) meshRef.current.count = count;
        const formScale = isFormed ? 1 : 0.01;
        particles.forEach((p, i) => { dummy.position.set(...p.pos); const s = p.randomScale * 0.4 * formScale; dummy.scale.set(s, s * 0.25, s); dummy.updateMatrix(); meshRef.current.setMatrixAt(i, dummy.matrix); });
        meshRef.current.instanceMatrix.needsUpdate = true;
        if(meshRef.current.material) { const targetEmissive = isLightsOff ? 0.0 : 0.1; meshRef.current.material.emissiveIntensity = THREE.MathUtils.lerp(meshRef.current.material.emissiveIntensity, targetEmissive, delta * 2); }
      });
      const geo = useMemo(() => new THREE.SphereGeometry(1, 32, 32), []);
      return ( <group> <instancedMesh ref={meshRef} args={[geo, undefined, count]} receiveShadow> <meshStandardMaterial color={color} emissive={color} emissiveIntensity={0.1} roughness={1.0} metalness={0.0} transparent={true} opacity={0.85} /> </instancedMesh> <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, -12.1, 0]} receiveShadow> <circleGeometry args={[spread + 2, 32]} /> <meshBasicMaterial color="#000000" transparent opacity={0.5} blending={THREE.MultiplyBlending} /> </mesh> </group> );
    };

    const SnowParticles = () => {
      const count = 2500; const matRef = useRef();
      const [data] = useState(() => {
        const pos = new Float32Array(count * 3); const randomness = new Float32Array(count * 3); const scales = new Float32Array(count);
        for(let i=0; i<count; i++) { pos[i*3] = (Math.random()-0.5)*80; pos[i*3+1] = (Math.random()-0.5)*60; pos[i*3+2] = (Math.random()-0.5)*80; randomness[i*3] = (Math.random()-0.5); randomness[i*3+1] = Math.random(); randomness[i*3+2] = (Math.random()-0.5); scales[i] = Math.random() * 1.5 + 0.5; }
        return { pos, randomness, scales };
      });
      useFrame((state) => { if(matRef.current) matRef.current.uniforms.uTime.value = state.clock.elapsedTime; });
      return ( <points> <bufferGeometry> <bufferAttribute attach="attributes-position" count={count} array={data.pos} itemSize={3} /> <bufferAttribute attach="attributes-aRandomness" count={count} array={data.randomness} itemSize={3} /> <bufferAttribute attach="attributes-aScale" count={count} array={data.scales} itemSize={1} /> </bufferGeometry> <shaderMaterial ref={matRef} vertexShader={snowVertexShader} fragmentShader={snowFragmentShader} uniforms={{ uTime: { value: 0 } }} transparent depthWrite={false} blending={THREE.AdditiveBlending} /> </points> );
    };

    const FloatingSparkles = ({ isFormed }) => {
      const count = 300; const meshRef = useRef(); const dummy = useMemo(() => new THREE.Object3D(), []);
      const particles = useMemo(() => Array.from({ length: count }).map(() => ({ basePos: new THREE.Vector3((Math.random() - 0.5) * 25, (Math.random() - 0.5) * 30, (Math.random() - 0.5) * 25), speed: 0.2 + Math.random() * 0.5, phase: Math.random() * Math.PI * 2, scale: 0.05 + Math.random() * 0.1 })), []);
      useFrame((state, delta) => {
        if (!meshRef.current || !isFormed) { if (meshRef.current) meshRef.current.visible = false; return; }
        meshRef.current.visible = true; const time = state.clock.elapsedTime;
        particles.forEach((p, i) => { dummy.position.copy(p.basePos); dummy.position.y += Math.sin(time * p.speed + p.phase) * 2.0; dummy.position.x += Math.cos(time * p.speed * 0.5 + p.phase) * 1.0; const sparkle = Math.sin(time * 3.0 + p.phase) * 0.5 + 0.5; dummy.scale.setScalar(p.scale * sparkle); dummy.updateMatrix(); meshRef.current.setMatrixAt(i, dummy.matrix); });
        meshRef.current.instanceMatrix.needsUpdate = true;
      });
      const geo = useMemo(() => new THREE.PlaneGeometry(1, 1), []);
      return ( <instancedMesh ref={meshRef} args={[geo, undefined, count]}> <meshBasicMaterial color="#FFD700" transparent opacity={0.8} blending={THREE.AdditiveBlending} depthWrite={false} side={THREE.DoubleSide} /> </instancedMesh> );
    };

    const GeometricGroup = ({ isFormed, type, color, geometry, count, scaleRange, isLightsOff, userIntensity }) => {
      const meshRef = useRef(null); const dummy = useMemo(() => new THREE.Object3D(), []);
      const items = useMemo(() => {
        const arr = [];
        for (let i = 0; i < count; i++) {
          const t = Math.pow(Math.random(), 1.2); const angle = Math.random() * Math.PI * 2; let minR = 0.85, maxR = 1.15;
          if (type === 'TREE_BODY') { minR = 0.0; maxR = 0.85; }
          const rOffset = minR + Math.random() * (maxR - minR); const point = getPineTreePoint(t, angle, rOffset); const jitter = type === 'TREE_BODY' ? 0.3 : 0.2;
          point.x += (Math.random()-0.5) * jitter; point.y += (Math.random()-0.5) * jitter; point.z += (Math.random()-0.5) * jitter;
          arr.push({ chaosPos: new THREE.Vector3((Math.random()-0.5)*60, (Math.random()-0.5)*60, (Math.random()-0.5)*60), targetPos: point, speed: (type === 'TREE_BODY' ? 1.0 : 1.5) * (0.8 + Math.random() * 0.4), scale: scaleRange[0] + Math.random() * (scaleRange[1] - scaleRange[0]), randomRot: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI) });
        }
        return arr;
      }, [count, type, scaleRange]);
      const progressRefs = useRef(new Float32Array(count).fill(0));
      useEffect(() => { progressRefs.current = new Float32Array(count).fill(isFormed ? 1 : 0); }, [count]);
      useFrame((state, delta) => {
        if (!meshRef.current) return; if (meshRef.current.count !== count) meshRef.current.count = count;
        items.forEach((item, i) => {
          const targetProgress = isFormed ? 1 : 0; progressRefs.current[i] = THREE.MathUtils.lerp(progressRefs.current[i], targetProgress, delta * item.speed); const p = progressRefs.current[i]; const ease = p * p * (3 - 2 * p);
          dummy.position.lerpVectors(item.chaosPos, item.targetPos, ease); let currentScale = item.scale; if (type === 'TREE_BODY') currentScale = item.scale * (0.5 + 0.5 * ease); dummy.scale.setScalar(currentScale);
          if (p < 0.9) { const rotTime = state.clock.elapsedTime * 2; dummy.rotation.set(rotTime + i, rotTime + i, 0); } else { dummy.rotation.copy(item.randomRot); dummy.rotation.y += Math.sin(state.clock.elapsedTime * 0.5 + i) * 0.02; }
          dummy.updateMatrix(); meshRef.current.setMatrixAt(i, dummy.matrix);
        });
        meshRef.current.instanceMatrix.needsUpdate = true;
        const isGlowType = ['GLOW_WHITE', 'STAR_GOLD', 'GLOW_GREEN', 'GLOW_RED'].includes(type);
        if (meshRef.current.material && isGlowType) {
           let defaultBase = 1.0; if (type === 'GLOW_WHITE') defaultBase = 4.0; else if (type === 'STAR_GOLD') defaultBase = 1.5; else if (type === 'GLOW_GREEN') defaultBase = 2.5; else if (type === 'GLOW_RED') defaultBase = 3.0;
           const baseIntensity = userIntensity || defaultBase; const targetIntensity = isLightsOff ? 0.1 : baseIntensity;
           meshRef.current.material.emissiveIntensity = THREE.MathUtils.lerp(meshRef.current.material.emissiveIntensity, targetIntensity, delta * 3);
        }
      });
      
      // === å…³é”®ä¿®å¤ï¼šæè´¨è°ƒæ•´ ===
      // å¦‚æœæ²¡æœ‰ç¯å¢ƒå…‰è´´å›¾ï¼Œé«˜é‡‘å±åº¦ä¼šå¯¼è‡´å…¨é»‘ã€‚
      // æ‰€ä»¥æˆ‘ä»¬æŠŠæ ‘èº«è®¾ä¸ºä½é‡‘å±åº¦(å¡‘æ–™æ„Ÿ)ï¼ŒæŒ‚ä»¶è®¾ä¸ºä¸­ç­‰é‡‘å±åº¦ã€‚
      let roughness = 0.5, metalness = 0.4, emissiveIntensity = 0, toneMapped = true;
      
      if (type === 'TREE_BODY') { 
          roughness = 0.6; metalness = 0.1; // æ ‘èº«ï¼šä½é‡‘å±åº¦ï¼Œä¿è¯æ˜¾è‰²
      }
      else if (type === 'HEAVY' || type === 'LIGHT') {
          roughness = 0.3; metalness = 0.5; // è£…é¥°çƒï¼šåŠé‡‘å±ï¼Œæœ‰å…‰æ³½ä½†ä¸è¿‡æ›
      }
      else if (type === 'GLOW_WHITE') { roughness = 0.9; metalness = 0.1; emissiveIntensity = userIntensity || 4.0; toneMapped = false; } 
      else if (type === 'STAR_GOLD') { roughness = 0.1; metalness = 0.6; emissiveIntensity = 1.5; toneMapped = false; }
      else if (type === 'GLOW_GREEN') { roughness = 0.2; metalness = 0.5; emissiveIntensity = 2.5; toneMapped = false; }
      else if (type === 'GLOW_RED') { roughness = 0.2; metalness = 0.5; emissiveIntensity = 3.0; toneMapped = false; }
      
      return ( <instancedMesh ref={meshRef} args={[geometry, undefined, count]} castShadow receiveShadow> <meshStandardMaterial color={color} roughness={roughness} metalness={metalness} emissive={emissiveIntensity > 0 ? color : undefined} emissiveIntensity={emissiveIntensity} toneMapped={toneMapped} /> </instancedMesh> );
    };

    const PhotoHanger = ({ texture }) => (
      <group>
        <mesh position={[0, -0.3, 0]}> <cylinderGeometry args={[0.008, 0.008, 0.6]} /> <meshStandardMaterial color="#FFD700" metalness={0.6} roughness={0.3} /> </mesh>
        <group position={[0, -0.7, 0]}>
          <mesh position={[0, 0.12, 0]}> <boxGeometry args={[0.1, 0.05, 0.02]} /> <meshStandardMaterial color="#FFD700" metalness={0.6} roughness={0.3} /> </mesh>
          <mesh position={[0, -0.15, -0.01]}> <planeGeometry args={[1.1, 1.35]} /> <meshStandardMaterial color="#fff" roughness={0.8} side={THREE.DoubleSide} /> </mesh>
          <mesh position={[0, -0.05, 0]}> <planeGeometry args={[1.0, 1.0]} /> <meshBasicMaterial map={texture} side={THREE.DoubleSide} /> </mesh>
        </group>
      </group>
    );

    const Polaroids = ({ isFormed, userTextures }) => {
      const count = 80;
      const defaultTex = useMemo(() => createDefaultTexture(), []);
      const items = useMemo(() => {
        const arr = [];
        for (let i = 0; i < count; i++) {
          const t = Math.pow(Math.random(), 1.4); const angle = Math.random() * Math.PI * 2; const point = getPineTreePoint(t, angle, 2.0); 
          arr.push({ chaosPos: new THREE.Vector3((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50), targetPos: point });
        }
        return arr;
      }, [count]);
      const groupRef = useRef();
      useFrame((state, delta) => {
        if(!groupRef.current) return;
        const targetP = isFormed ? 1 : 0;
        items.forEach((item, i) => {
          const wrapper = groupRef.current.children[i]; if(!wrapper) return;
          wrapper.userData.p = THREE.MathUtils.lerp(wrapper.userData.p || 0, targetP, delta * 1.5);
          const p = wrapper.userData.p; const ease = p * p * (3 - 2 * p);
          wrapper.position.lerpVectors(item.chaosPos, item.targetPos, ease); wrapper.scale.setScalar(1); 
          wrapper.lookAt(0, wrapper.position.y, 0); wrapper.rotateY(Math.PI); 
          const inner = wrapper.children[0];
          if (inner) { 
             const wind = Math.sin(state.clock.elapsedTime * 2 + i) * 0.1; 
             inner.rotation.x = (-0.4 + Math.abs(wind) * 0.3) * (p > 0.9 ? 1 : 0);
             inner.rotation.z = wind * 0.5 * (p > 0.9 ? 1 : 0); 
          }
        });
      });
      return ( <group ref={groupRef}> {items.map((item, i) => { const tex = (userTextures && userTextures.length > 0) ? userTextures[i % userTextures.length] : defaultTex; return ( <group key={i}> <PhotoHanger texture={tex} /> </group> ); })} </group> );
    };

    const SceneContent = ({ isFormed, userTextures, isLightsOff }) => {
      const sphereGeo = useMemo(() => new THREE.SphereGeometry(1, 16, 16), []);
      const boxGeo = useMemo(() => new THREE.BoxGeometry(0.8, 0.8, 0.8), []); 
      const jewelGeo = useMemo(() => new THREE.IcosahedronGeometry(0.5, 0), []); 
      const starDecoGeo = useMemo(() => { const shape = createStarShape(0.4); return new THREE.ExtrudeGeometry(shape, { depth: 0.1, bevelEnabled: true, bevelSize: 0.02, bevelThickness: 0.02 }); }, []);

      return (
        <>
          <group position={[0, -2, 0]}>
            <TreeTrunk isFormed={isFormed} />
            <GiftBoxes isFormed={isFormed} />
            <CloudySnowFloor isFormed={isFormed} isLightsOff={isLightsOff} />
            <GeometricGroup isFormed={isFormed} type="TREE_BODY" color={THEME.bodyColor} geometry={jewelGeo} count={2500} scaleRange={[0.6, 1.2]} />
            <GeometricGroup isFormed={isFormed} type="LIGHT" color={THEME.lightColor} geometry={sphereGeo} count={100} scaleRange={[0.25, 0.45]} />
            <GeometricGroup isFormed={isFormed} type="HEAVY" color={THEME.heavyColor} geometry={sphereGeo} count={80} scaleRange={[0.3, 0.5]} />
            <GeometricGroup isFormed={isFormed} type="STAR_GOLD" color={THEME.starBodyColor} geometry={starDecoGeo} count={40} scaleRange={[0.8, 1.2]} isLightsOff={isLightsOff} />
            <GeometricGroup isFormed={isFormed} type="GLOW_GREEN" color={THEME.gemAColor} geometry={jewelGeo} count={120} scaleRange={[0.3, 0.5]} isLightsOff={isLightsOff} />
            <GeometricGroup isFormed={isFormed} type="GLOW_RED" color={THEME.gemBColor} geometry={jewelGeo} count={120} scaleRange={[0.3, 0.5]} isLightsOff={isLightsOff} />
            <GeometricGroup isFormed={isFormed} type="GLOW_WHITE" color="#ffffff" geometry={boxGeo} count={200} scaleRange={[0.15, 0.25]} isLightsOff={isLightsOff} />
            <Polaroids isFormed={isFormed} userTextures={userTextures} />
            <StarTopper isFormed={isFormed} color={THEME.starBodyColor} isLightsOff={isLightsOff} />
          </group>
          <FloatingSparkles isFormed={isFormed} />
          <SnowParticles />
          <Stars radius={300} depth={50} count={5000} factor={4} saturation={0} fade speed={1} />
          <ContactShadows opacity={0.6} scale={40} blur={2.5} far={10} resolution={256} color="#000000" />
        </>
      );
    };

    const App = () => {
      const [isFormed, setIsFormed] = useState(false);
      const [isLightsOff, setIsLightsOff] = useState(false);
      const [userTextures, setUserTextures] = useState([]);
      const [showMagic, setShowMagic] = useState(false);
      const controlsRef = useRef();

      // âœ… Auto-load photos from /photos on page load.
      // Works with 1..25 photos. Expected names: photos/01.png ... photos/25.png
      useEffect(() => {
        const loader = new THREE.TextureLoader();

        const makeUrls = () =>
          Array.from({ length: 25 }, (_, i) => {
            const n = String(i + 1).padStart(2, "0");
            return `photos/${n}.png`;
          });

        const urls = makeUrls();
        let cancelled = false;

        const loadWithFallback = (url) =>
          new Promise((resolve) => {
            // try lowercase .png first
            loader.load(
              url,
              (tex) => {
                tex.colorSpace = THREE.SRGBColorSpace;
                resolve(tex);
              },
              undefined,
              () => {
                // if it fails, try uppercase .PNG (case-sensitive filesystems)
                const alt = url.replace(/\.png$/i, ".PNG");
                if (alt === url) return resolve(null);
                loader.load(
                  alt,
                  (tex2) => {
                    tex2.colorSpace = THREE.SRGBColorSpace;
                    resolve(tex2);
                  },
                  undefined,
                  () => resolve(null)
                );
              }
            );
          });

        Promise.all(urls.map(loadWithFallback)).then((textures) => {
          const ok = textures.filter(Boolean);
          if (cancelled) return;

          if (ok.length > 0) {
            setUserTextures(ok);
            setPhotoStatus(`å·²è‡ªåŠ¨åŠ è½½ ${ok.length} å¼ ç…§ç‰‡`);
          } else {
            setPhotoStatus("æœªæ£€æµ‹åˆ°è‡ªåŠ¨ç…§ç‰‡ï¼ˆå¯ç”¨å·¦ä¸‹è§’æŒ‰é’®ä¸Šä¼ ï¼‰");
          }
        });

        return () => {
          cancelled = true;
        };
      }, []);

      const handlePhotoUpload = (e) => { const files = Array.from(e.target.files); if (files.length > 0) { const newTextures = []; const loader = new THREE.TextureLoader(); files.forEach(file => { const url = URL.createObjectURL(file); loader.load(url, (tex) => { tex.colorSpace = THREE.SRGBColorSpace; newTextures.push(tex); if(newTextures.length === files.length) setUserTextures(newTextures); }); }); } };
      const handleGestureUpdate = (data) => { if (data.type === 'FIST') setIsFormed(true); if (data.type === 'OPEN') setIsFormed(false); if (data.type === 'VICTORY') setIsLightsOff(true); else setIsLightsOff(false); if (data.type === 'POINT' && controlsRef.current) { if (data.x < 0.4) controlsRef.current.setAzimuthalAngle(controlsRef.current.getAzimuthalAngle() + 0.15); else if (data.x > 0.6) controlsRef.current.setAzimuthalAngle(controlsRef.current.getAzimuthalAngle() - 0.15); if (data.y < 0.3) controlsRef.current.setPolarAngle(Math.max(0.1, controlsRef.current.getPolarAngle() - 0.1)); else if (data.y > 0.7) controlsRef.current.setPolarAngle(Math.min(Math.PI/2, controlsRef.current.getPolarAngle() + 0.1)); } };

      return (
        <div className="w-full h-full relative font-cn bg-black overflow-hidden">
          {showMagic && <GestureController onUpdate={handleGestureUpdate} />}
          <div className="absolute top-0 left-0 w-full h-full pointer-events-none z-10">
            <div className="absolute top-8 left-8 md:top-12 md:left-12 text-left">
              <h1 className="font-title text-5xl md:text-7xl text-yellow-500 drop-shadow-[0_0_15px_rgba(255,215,0,0.6)]">Merry Christmas</h1>
              <div className="flex items-center gap-3 mt-2"><div className="h-[1px] w-12 bg-yellow-500/50"></div><p className="font-cn text-purple-200/80 text-sm md:text-base tracking-[0.2em] uppercase drop-shadow-md">WISH EVERYONE PRO EXAM A AND GET RICH RICH</p></div>
            </div>
            <div className="absolute top-8 right-8 md:top-12 md:right-12 pointer-events-auto flex gap-4">
              <button onClick={() => setIsLightsOff(!isLightsOff)} className={`glass-btn px-4 py-2 rounded-full text-yellow-500 font-bold text-sm tracking-widest uppercase flex items-center gap-2 group ${isLightsOff ? 'bg-yellow-500/30' : ''}`}><span>{isLightsOff ? "ğŸ’¡ LIGHTS ON" : "ğŸŒ™ LIGHTS OFF"}</span></button>
              <button onClick={() => setShowMagic(!showMagic)} className={`glass-btn px-4 py-2 rounded-full text-yellow-500 font-bold text-sm tracking-widest uppercase flex items-center gap-2 group ${showMagic ? 'bg-yellow-500/30' : ''}`}><span>ğŸ¥ MAGIC</span></button>
            </div>
            {showMagic && ( <div className="absolute top-28 right-8 text-right text-yellow-100/60 text-xs font-cn pointer-events-auto bg-black/40 px-3 py-2 rounded-lg backdrop-blur-sm border border-yellow-500/20"> <p>âœŠ æ¡æ‹³ï¼šå‡èš</p> <p>ğŸ– å¼ å¼€ï¼šæ¶ˆæ•£</p> <p>âœŒ æ¯”è€¶ï¼šå…³ç¯</p> </div> )}
            <div className="absolute bottom-8 left-8 md:bottom-12 md:left-12 pointer-events-auto flex flex-col gap-4">
              <label className="glass-btn px-5 py-2 rounded-full cursor-pointer flex items-center gap-3 group text-yellow-100/90 hover:text-yellow-500 transition-all"><span className="text-xl">ğŸ“·</span><span className="text-sm font-bold tracking-widest uppercase">UPLOAD</span><input type="file" accept="image/*" multiple onChange={handlePhotoUpload} /></label>
            </div>
            <div className="absolute bottom-8 right-8 md:bottom-12 md:right-12 pointer-events-auto">
              <button onClick={() => setIsFormed(!isFormed)} className={`relative w-20 h-20 md:w-24 md:h-24 rounded-full flex items-center justify-center border-2 border-yellow-500/50 backdrop-blur-md transition-all duration-700 hover:scale-110 hover:border-yellow-500 hover:shadow-[0_0_50px_rgba(255,215,0,0.4)] ${isFormed ? 'bg-yellow-500/20' : 'bg-black/40'}`}><div className="text-center"><div className="text-2xl md:text-3xl mb-1">{isFormed ? "âœ¨" : "ğŸ„"}</div><div className="text-[10px] md:text-xs font-bold text-yellow-500 uppercase tracking-widest">{isFormed ? "RELEASE" : "GATHER"}</div></div></button>
            </div>
          </div>
          <Canvas shadows dpr={[1, 1.5]} camera={{ position: [0, 4, 25], fov: 45 }} gl={{ toneMapping: THREE.ACESFilmicToneMapping, toneMappingExposure: 1.1 }}>
            <color attach="background" args={['#000000']} />
            <Suspense fallback={null}>
              {/* === å…³é”®ä¿®å¤ï¼šå¢å¼ºç¯å…‰ç³»ç»Ÿ === */}
              {/* 1. ç¯å¢ƒå…‰ï¼šåŸºç¡€äº®åº¦ */}
              <ambientLight intensity={isLightsOff ? 0.1 : 0.8} />
              
              {/* 2. åŠçƒå…‰ï¼šæ¨¡æ‹Ÿå¤©ç©ºå’Œåœ°é¢çš„é¢œè‰²å·® */}
              <hemisphereLight intensity={isLightsOff ? 0.1 : 0.5} groundColor="#000000" color="#223344" />
              
              {/* 3. ä¾§é¢è¡¥å…‰ï¼šè®©æ ‘æœ‰ä½“ç§¯æ„Ÿ */}
              <directionalLight position={[-5, 5, 5]} intensity={isLightsOff ? 0 : 5} color="#ffd700" />
              
              {/* 4. åŸæœ‰çš„èšå…‰ç¯å’Œç‚¹å…‰æº */}
              <spotLight position={[10, 20, 10]} angle={0.4} penumbra={1} intensity={isLightsOff ? 10 : 200} castShadow color="#FFD700" />
              <pointLight position={[-10, 5, -10]} intensity={isLightsOff ? 5 : 80} color="#ffffff" />
              <pointLight position={[0, -5, 10]} intensity={30} color={THEME.bodyColor} />
              
              <SceneContent isFormed={isFormed} userTextures={userTextures} isLightsOff={isLightsOff} />
              <EffectComposer disableNormalPass><Bloom luminanceThreshold={1.0} mipmapBlur intensity={1.8} radius={0.5} /><Vignette eskil={false} offset={0.1} darkness={1.1} /></EffectComposer>
            </Suspense>
            <OrbitControls ref={controlsRef} enablePan={false} maxPolarAngle={Math.PI / 2 + 0.1} minDistance={5} maxDistance={40} autoRotate={isFormed} autoRotateSpeed={0.5} />
          </Canvas>
        </div>
      );
    };


    const root = createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>